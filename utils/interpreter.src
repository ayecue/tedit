//Obfuscated and minified :)
Z=function(I)
Ф=I[0]
Ц=I[1]
Ә=I[2]
d={"members":{}}
d.add=function(f,g)
N=self
N.members[f]=g
return N
end function
d.isInstanceOf=function(j)
N=self
return N.members.hasIndex(typeof(@j))
end function
d.get=function(f)
N=self
if N.members.hasIndex(f) then
return N.members[f]
end if
return null
end function
l={"members":{}}
l.add=function(f,g)
N=self
N.members[f]=g
return N
end function
l.isInstanceOf=function(j)
N=self
return N.members.hasIndex(typeof(@j))
end function
l.get=function(f)
N=self
if N.members.hasIndex(f) then
return N.members[f]
end if
return null
end function
l.ExpressionManager=d
d.OperationManager=l
ӟ={"members":{}}
ӟ.add=function(n)
N=self
N.members[n.id]=n
return N
end function
ӟ.get=function(f)
N=self
if N.members.hasIndex(f) then
return N.members[f]
end if
return null
end function
p={"members":{}}
p.add=function(n)
N=self
N.members[n.id]=n
return N
end function
p.get=function(f)
N=self
if N.members.hasIndex(f) then
return N.members[f]
end if
return null
end function
q={}
d.add("AssignExpression",q)
q.dynResolve=Ф
q.ExpressionManager=d
q.OperationManager=l
q.FunctionRegistry=ӟ
q.ScopeRegistry=p
q.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
Ѕ=null
if (u.type=="AssignmentStatement") then
g={"left":N.build(u.variable),"right":N.build(u.init)}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="AssignExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
q.get=function(ϫ,Ϭ)
N=self
ϭ=function(u)
N=self.instance
ϯ=self.opc
if not N.ExpressionManager.isInstanceOf(u.left) then
ϯ.dbgr.raise(["Unexpected left assignment",N,ϰ].join(" "))
end if
ϰ=u.left.get(ϯ,N.expr)
ϳ=@u.right
if N.ExpressionManager.isInstanceOf(@ϳ) then
ϳ=ϳ.get(ϯ)
else if N.OperationManager.isInstanceOf(@ϳ) then
ϳ=ϳ.get(ϯ)
if (typeof(@ϳ)=="proxyFunction") then
ϳ=N.FunctionRegistry.get(ϳ.id)
end if
ϴ=ϰ.path.len
if ((typeof(@ϳ)=="FunctionOperation") and (typeof(ϰ.handle)!="null")) then
ϸ=typeof(ϰ.handle)
if (((ϸ!="string") and (ϸ!="number")) and (ϸ!="boolean")) then
ϳ=ϳ.fork(ϰ.handle)
end if
end if
else if (@ϳ==null) then
ϯ.dbgr.raise(["Unexpected right assignment",N,@ϳ].join(" "))
end if
if (typeof(ϰ.handle)!="null") then
Ϻ=typeof(ϰ.handle)
if (Ϻ=="proxyScope") then
ϯ.dbgr.debug({"type":"AssignExpression","description":"assign with operationContext","leftType":Ϻ,"right":@ϳ})
ϻ=N.ScopeRegistry.get(ϰ.handle.id)
ϻ.set(ϰ.path,@ϳ)
return true
end if
ϯ.dbgr.debug({"type":"AssignExpression","description":"assign with handle","leftType":Ϻ,"right":@ϳ})
if (((Ϻ!="string") and (Ϻ!="boolean")) and (Ϻ!="number")) then
Ͻ=ϰ.path
Ͼ=ϰ.handle
N.dynResolve.set(Ͼ,Ͻ,@ϳ)
return true
else
ϯ.dbgr.raise(["Unexpected left assignment",N,ϰ].join(" "))
end if
end if
ϯ.dbgr.debug({"type":"AssignExpression","description":"assign with scope","path":ϰ.path,"right":@ϳ})
ϯ.set(ϰ.path,@ϳ)
return true
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϫ}
ϫ.dbgr.debug({"type":"AssignExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr)
end function
Ђ={}
d.add("BinaryNegatedExpression",Ђ)
Ђ.dynResolve=Ф
Ђ.ExpressionManager=d
Ђ.OperationManager=l
Ѓ=function(Є)
return Є
end function
І=function(Є)
return (Є*-1)
end function
Ђ.OPERATIONS={"+":@Ѓ,"-":@І}
Ђ.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
if (u.type=="BinaryNegatedExpression") then
g={"classID":u.type,"operator":u.operator,"arg":N.build(u.arg)}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="BinaryNegatedExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
Ђ.get=function(ϫ,Ϭ)
N=self
ϭ=function(u)
N=self.instance
ϫ=self.opc
if (typeof(u)=="BinaryNegatedExpression") then
Љ=self.eval(u.arg)
n=@N.OPERATIONS[u.operator]
return n(Љ)
end if
if (N.ExpressionManager.isInstanceOf(u) or N.OperationManager.isInstanceOf(u)) then
return u.get(ϫ)
end if
return u
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϫ}
ϫ.dbgr.debug({"type":"BinaryNegatedExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr)
end function
Њ={}
d.add("CallExpression",Њ)
Њ.dynResolve=Ф
Њ.dynApply=Ә
Њ.ExpressionManager=d
Њ.OperationManager=l
Њ.FunctionRegistry=ӟ
Њ.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
Ѕ=null
if (u.type=="CallStatement") then
g=N.build(u.expression)
else if (u.type=="CallExpression") then
Ћ=[]
for Ќ in u.arguments
Ћ.push(N.cpsWalker.visit(Ќ))
end for
g={"classID":"call","path":N.build(u.base),"args":Ћ}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="CallExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
Њ.get=function(ϫ,Ϭ)
N=self
Џ=function(Ћ)
N=self.instance
ϯ=self.opc
А=[]
for Ќ in Ћ
ϯ.dbgr.debug({"type":"CallExpression","description":"resolve arg","item":@Ќ})
if (N.ExpressionManager.isInstanceOf(@Ќ) or N.OperationManager.isInstanceOf(@Ќ)) then
А.push(Ќ.get(ϯ))
else
А.push(@Ќ)
end if
end for
return А
end function
ϭ=function(u)
N=self.instance
ϯ=self.forkedOpc
if N.ExpressionManager.isInstanceOf(u) then
return u.get(ϯ)
end if
Ћ=self.resolveArgs(u.args)
ϯ.dbgr.debug({"type":"CallExpression","description":"resolved args","args":Ћ})
if (typeof(u.path)=="call") then
В=self.eval(u.path)
if (typeof(В)=="proxyFunction") then
В=N.FunctionRegistry.get(В.id)
end if
if N.OperationManager.isInstanceOf(В) then
ϯ.setMemory("args",Ћ)
return В.run(ϯ)
else
ϯ.dbgr.raise(["CallExpression","Unexpected handle result",N,В].join(" "))
end if
end if
Е=u.path.get(ϯ,N.expr)
ϯ.dbgr.debug({"type":"CallExpression","description":"get path expr result","pathExpr":Е})
ϸ=typeof(@Е.handle)
if (ϸ!="null") then
Ж=N.dynResolve.getCallable(@Е.handle,Е.path)
ϯ.dbgr.debug({"type":"CallExpression","description":"handle callable","callable":Ж})
ϯ.setMemory("args",Ћ)
if (typeof(@Ж.origin)=="proxyFunction") then
Ж.origin=N.FunctionRegistry.get(Ж.origin.id)
end if
if N.OperationManager.isInstanceOf(@Ж.origin) then
return Ж.origin.run(ϯ)
else if (typeof(@Ж.origin)=="function") then
return N.dynApply.apply(@Ж.origin,Ћ,Ж.context)
end if
ϯ.dbgr.raise({"type":"CallExpression","description":"Unexpected handle call","pathExpr":Е,"callable":Ж})
end if
Ж=ϯ.getCallable(Е.path)
ϯ.dbgr.debug({"type":"CallExpression","description":"operationContext","callable":Ж})
ϯ.setMemory("args",Ћ)
if (typeof(@Ж.origin)=="proxyFunction") then
Ж.origin=N.FunctionRegistry.get(Ж.origin.id)
end if
if N.OperationManager.isInstanceOf(@Ж.origin) then
А=Ж.origin.run(ϯ)
return А
else if (typeof(@Ж.origin)=="function") then
return N.dynApply.apply(@Ж.origin,Ћ,Ж.context)
end if
return @Ж.origin
end function
Ͽ={"instance":N,"eval":@ϭ,"resolveArgs":@Џ,"opc":ϫ,"forkedOpc":ϫ.fork("CALL","TEMPORARY")}
ϫ.dbgr.debug({"type":"CallExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr)
end function
К={}
d.add("ListExpression",К)
К.dynResolve=Ф
К.ExpressionManager=d
К.OperationManager=l
К.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
if (u.type=="ListConstructorExpression") then
Л=[]
for Ќ in u.fields
Л.push(N.cpsWalker.visit(Ќ.value))
end for
g={"classID":"listexpr","values":Л}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="ListExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
К.get=function(ϫ,Ϭ)
N=self
ϭ=function(u)
N=self.instance
ϫ=self.opc
Н=([]+u)
О=[]
П=Н.pull
while (typeof(П)!="null")
if (typeof(П)=="listexpr") then
О.push(N.eval(П.values))
else if (N.ExpressionManager.isInstanceOf(П) or N.OperationManager.isInstanceOf(П)) then
О.push(П.get(ϫ))
else
О.push(П)
end if
П=Н.pull
end while
return О
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϫ}
ϫ.dbgr.debug({"type":"ListExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr.values)
end function
Т={}
d.add("LogicalAndBinaryExpression",Т)
Т["+"]=function(У,Х)
return (У+Х)
end function
Т["-"]=function(У,Х)
return (У-Х)
end function
Т["/"]=function(У,Х)
return (У/Х)
end function
Т["*"]=function(У,Х)
return (У*Х)
end function
Т["<"]=function(У,Х)
return (У<Х)
end function
Т[">"]=function(У,Х)
return (У>Х)
end function
Т["%"]=function(У,Х)
return (У%Х)
end function
Т[">="]=function(У,Х)
return (У>=Х)
end function
Т["=="]=function(У,Х)
return (У==Х)
end function
Т["<="]=function(У,Х)
return (У<=Х)
end function
Т["=="]=function(У,Х)
return (У==Х)
end function
Т["<="]=function(У,Х)
return (У<=Х)
end function
Т["!="]=function(У,Х)
return (У!=Х)
end function
Т["and"]=function(У,Х)
return (У and Х)
end function
Т["or"]=function(У,Х)
return (У or Х)
end function
Т["^"]=function(У,Х)
return bitwise("^",У,Х)
end function
Т["|"]=function(У,Х)
return bitwise("|",У,Х)
end function
Т["<<"]=function(У,Х)
return bitwise("<<",У,Х)
end function
Т[">>"]=function(У,Х)
return bitwise(">>",У,Х)
end function
Т[">>>"]=function(У,Х)
return bitwise(">>>",У,Х)
end function
Т["&"]=function(У,Х)
return bitwise("&",У,Х)
end function
Т.OPERATIONS=Т
Т.dynApply=Ә
Т.dynResolve=Ф
Т.ExpressionManager=d
Т.OperationManager=l
Т.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
if ((u.type=="LogicalExpression") or (u.type=="BinaryExpression")) then
g={"classID":u.type,"operator":u.operator,"left":N.build(u.left),"right":N.build(u.right)}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="LogicalAndBinaryExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
Т.get=function(ϫ,Ϭ)
N=self
ϭ=function(u)
N=self.instance
ϫ=self.opc
ϰ=null
ϳ=null
w=typeof(u)
ϫ.dbgr.debug({"type":"LogicalAndBinaryExpression","description":"type","val":w})
if (w=="BinaryExpression") then
ϰ=self.eval(u.left)
ϳ=self.eval(u.right)
return N.dynApply.apply(N.OPERATIONS[u.operator],[ϰ,ϳ])
else if (w=="LogicalExpression") then
ϰ=self.eval(u.left)
if ((typeof(ϰ)=="list") and not ϰ) then
ϰ=false
end if
if ((u.operator=="and") and not ϰ) then
return false
else if ((u.operator=="or") and ϰ) then
return true
end if
ϳ=self.eval(u.right)
return N.dynApply.apply(N.OPERATIONS[u.operator],[ϰ,ϳ])
end if
if (N.ExpressionManager.isInstanceOf(u) or N.OperationManager.isInstanceOf(u)) then
return u.get(ϫ)
end if
return u
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϫ}
ϫ.dbgr.debug({"type":"LogicalAndBinaryExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr)
end function
Ч={}
d.add("MapExpression",Ч)
Ч.dynResolve=Ф
Ч.ExpressionManager=d
Ч.OperationManager=l
Ч.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
g=null
if (u.type=="MapConstructorExpression") then
Л=[]
for Ќ in u.fields
Л.push({"key":N.cpsWalker.visit(Ќ.key),"value":N.build(Ќ.value)})
end for
g={"classID":"mapexpr","values":Л}
else
g=N.cpsWalker.visit(u)
end if
return g
end function
_={"cpsWalker":s,"build":@t}
N.classID="MapExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
Ч.get=function(ϫ,Ϭ)
N=self
ϭ=function(u)
N=self.instance
ϫ=self.opc
Н=([]+u)
Ш={}
П=Н.pull
while П
f=null
М=null
if (typeof(П.key)=="string") then
f=П.key
else
ϫ.dbgr.raise(["Unexpected key",N,П.key].join(" "))
end if
if (typeof(П.value)=="mapexpr") then
М=self.eval(П.value.values)
else if (N.ExpressionManager.isInstanceOf(П.value) or N.OperationManager.isInstanceOf(П.value)) then
М=П.value.get(ϫ)
else
М=П.value
end if
Ш[f]=М
П=Н.pull
end while
return Ш
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϫ}
ϫ.dbgr.debug({"type":"MapExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
return Ͽ.eval(N.expr.values)
end function
Щ={}
d.add("PathExpression",Щ)
Щ.dynResolve=Ф
Щ.dynApply=Ә
Щ.ExpressionManager=d
Щ.OperationManager=l
Щ.FunctionRegistry=ӟ
Щ.ScopeRegistry=p
Щ.constructor=function(Ԁ,s)
N=self
Ъ=function(ϩ,Є)
if (typeof(Є)=="list") then
return (ϩ+Є)
end if
return (ϩ+[Є])
end function
t=function(u)
N=self
g=[]
if (u.type=="MemberExpression") then
g=N.append(g,N.build(u.base))
g=N.append(g,N.build(u.identifier))
else if (u.type=="IndexExpression") then
g=N.append(g,N.build(u.base))
Ь=N.dynResolve.get(u.index,"type")
if (Ь=="SliceExpression") then
g=N.append(g,{"classID":"slice","left":N.cpsWalker.visit(u.index.left),"right":N.cpsWalker.visit(u.index.right)})
else
g=N.append(g,{"classID":"index","value":N.cpsWalker.visit(u.index)})
end if
else if (u.type=="Identifier") then
g=N.append(g,{"classID":"path","value":u.value})
else
g=N.append(g,N.cpsWalker.visit(u))
end if
return g
end function
_={"dynResolve":N.dynResolve,"cpsWalker":s,"build":@t,"append":@Ъ}
N.classID="PathExpression"
N.ast=Ԁ
N.expr=_.build(Ԁ)
N.isExpression=true
N.cpsWalker=s
return N
end function
Щ.getByIndex=function(Э)
return self.expr[Э]
end function
Щ.get=function(ϫ,Ϭ)
N=self
ϯ=ϫ
ϭ=function(u)
N=self.instance
ϯ=self.opc
Н=([]+u)
Я=[]
а=0
Ϸ=null
П=Н.pull
while П
б=typeof(П)
if N.ExpressionManager.isInstanceOf(П) then
Ϸ=П.get(ϯ,N.expr)
else if N.OperationManager.isInstanceOf(П) then
Ϸ=П.get(ϯ)
else if (б=="path") then
ϯ.dbgr.debug({"type":"PathExpression","description":"current path","path":П.value})
if ((П.value=="self") and (а==0)) then
в=ϯ.getMemory("functionContext")
Ͼ=N.dynResolve.get(в,"context")
if (typeof(Ͼ)!="null") then
Ϸ=в.context
else
ϯ.dbgr.raise(["Unexpected self",N,П].join(" "))
end if
else
Я.push(П.value)
if (Н.len>0) then
ϸ=typeof(@Ϸ)
if (ϸ!="null") then
И=Ϸ
else
И=@ϯ
end if
д=typeof(@И)
ϯ.dbgr.debug({"type":"PathExpression","description":"traversed","origin":@И,"originType":д})
if (д=="proxyScope") then
ϻ=N.ScopeRegistry.get(И.id)
Ϸ=ϻ.get(Я)
else if ((д=="operationContext") or N.ExpressionManager.isInstanceOf(@И)) then
Ϸ=И.get(Я)
else
Ж=N.dynResolve.getCallable(@И,Я)
д=typeof(@Ж.origin)
ϯ.dbgr.debug({"type":"PathExpression","description":"traversed","callable":Ж})
if (д=="function") then
Ϸ=N.dynApply.apply(@Ж.origin,null,Ж.context)
else if (д=="operationContext") then
Ϸ=Ж.origin.createProxy
else
Ϸ=@Ж.origin
end if
end if
Я=[]
end if
end if
else if (б=="index") then
П=П.value
if N.ExpressionManager.isInstanceOf(П) then
М=П.get(ϯ)
Я.push(М)
else
Я.push(П)
end if
else if (б=="slice") then
if not Ϸ then
Ϸ=ϯ.get(Я)
Я=[]
else if ((typeof(Ϸ)!="list") and (typeof(Ϸ)!="string")) then
ϯ.dbgr.raise({"type":"PathExpression","description":"Invalid type for slice","instance":N,"handle":Ϸ})
end if
ϰ=П.left
if N.ExpressionManager.isInstanceOf(ϰ) then
ϰ=ϰ.get(ϯ)
end if
ϳ=П.right
if N.ExpressionManager.isInstanceOf(ϳ) then
ϳ=ϳ.get(ϯ)
end if
Ϸ=Ϸ[ϰ:ϳ]
else
Ϸ=П
end if
а=(а+1)
П=Н.pull
end while
return {"classID":"pathResult","handle":Ϸ,"path":Я}
end function
Ͽ={"instance":N,"eval":@ϭ,"opc":ϯ}
ϯ.dbgr.debug({"type":"PathExpression","description":"get expr","line":N.ast.line,"expr":N.expr})
ж=Ͽ.eval(N.expr)
ϯ.dbgr.debug({"type":"PathExpression","description":"result","result":ж,"parent":Ϭ})
if not Ϭ then
ϸ=typeof(ж.handle)
if (ϸ!="null") then
if (ж.path.len==0) then
if (typeof(@ж.handle)=="operationContext") then
return ж.handle.createProxy
end if
return ж.handle
end if
Ж=null
ϯ.dbgr.debug({"type":"PathExpression","description":"get callable","callable":ϸ})
if (ϸ=="proxyScope") then
з=N.ScopeRegistry.get(ж.handle.id)
Ж=з.getCallable(ж.path)
else
Ж=N.dynResolve.getCallable(ж.handle,ж.path)
end if
ϯ.dbgr.debug({"type":"PathExpression","description":"is path with handle callable","callable":Ж})
if (typeof(@Ж.origin)=="proxyFunction") then
Ж.origin=N.FunctionRegistry.get(Ж.origin.id)
end if
if N.OperationManager.isInstanceOf(@Ж.origin) then
return Ж.origin.run(ϯ)
else if (typeof(@Ж.origin)!="function") then
return Ж.origin
end if
return N.dynApply.apply(@Ж.origin,null,Ж.context)
end if
М=ϯ.get(ж.path)
ϯ.dbgr.debug({"type":"PathExpression","description":"get with opc","value":@М,"opc":ϯ})
if (typeof(@М)=="proxyFunction") then
М=N.FunctionRegistry.get(М.id)
end if
и=typeof(@М)
if (и=="function") then
Ж=ϯ.getCallable(ж.path)
return N.dynApply.apply(@Ж.origin,null,Ж.context)
else if N.OperationManager.isInstanceOf(М) then
return М.run(ϯ)
else if ((и=="operationContext") or (и=="scope")) then
return М.createProxy
end if
return М
end if
return ж
end function
й={}
l.add("ArgumentOperation",й)
й.dynResolve=Ф
й.ExpressionManager=d
й.OperationManager=l
й.constructor=function(Ԁ,s)
N=self
N.classID="ArgumentOperation"
N.ast=Ԁ
N.stack=[]
N.isOperation=true
N.cpsWalker=s
return N
end function
й.run=function(ϫ)
N=self
ϫ.dbgr.raise(("Unexpected run call on "+typeof(N)))
end function
й.get=function(ϫ)
N=self
к=N.stack
Ћ=[]
for м in N.stack
н=м.path.get(ϫ,N)
if (м.defaultValue!=null) then
if (N.ExpressionManager.isInstanceOf(м.defaultValue) or N.OperationManager.isInstanceOf(м.defaultValue)) then
о=м.get(ϫ,N)
else
о=м.defaultValue
end if
ϫ.set(н.path,о)
end if
Ћ.push(н.path)
end for
return Ћ
end function
п={}
l.add("BodyOperation",п)
п.dynResolve=Ф
п.ExpressionManager=d
п.OperationManager=l
п.constructor=function(Ԁ,s)
N=self
N.classID="BodyOperation"
N.ast=Ԁ
N.stack=[]
N.isOperation=true
N.cpsWalker=s
return N
end function
п.run=function(ϫ)
N=self
р={}
р.is=function()
return false
end function
if (ϫ.type=="LOOP") then
р.context=ϫ.getMemory("loopContext")
р.is=function()
return (self.context.isBreak or self.context.isContinue)
end function
else if (ϫ.type=="FUNCTION") then
р.context=ϫ.getMemory("functionContext")
р.is=function()
return self.context.isReturn
end function
end if
for м in N.stack
if ϫ.dbgr.getBreakPoint then
ϫ.dbgr.interact(ϫ,м.ast.line)
end if
if N.ExpressionManager.isInstanceOf(м) then
м.get(ϫ)
else
м.run(ϫ)
end if
if р.is then
break
end if
end for
end function
ч={}
l.add("BreakOperation",ч)
ч.constructor=function(Ԁ,s)
N=self
N.classID="BreakOperation"
N.ast=Ԁ
N.isOperation=true
N.cpsWalker=s
return N
end function
ч.run=function(ϫ)
N=self
ш=ϫ.getMemory("loopContext")
ш.isBreak=true
end function
щ={}
l.add("ContinueOperation",щ)
щ.constructor=function(Ԁ,s)
N=self
N.classID="ContinueOperation"
N.ast=Ԁ
N.isOperation=true
N.cpsWalker=s
return N
end function
щ.run=function(ϫ)
N=self
ш=ϫ.getMemory("loopContext")
ш.isContinue=true
end function
ъ={}
l.add("DebuggerOperation",ъ)
ъ.constructor=function(Ԁ,s)
N=self
N.classID="DebuggerOperation"
N.ast=Ԁ
N.isOperation=true
N.cpsWalker=s
return N
end function
ъ.run=function(ϫ)
N=self
ϫ.dbgr.setBreakPoint(true)
ϫ.dbgr.interact(ϫ,N.ast.line)
end function
ь={}
l.add("ElseIfOperation",ь)
ь.constructor=function(Ԁ,s)
N=self
N.classID="ElseIfOperation"
N.ast=Ԁ
N.condition=null
N.body=null
N.isOperation=true
N.cpsWalker=s
return N
end function
ь.run=function(ϫ)
N=self
ϫ.dbgr.raise(("Unexpected run call on "+typeof(N)))
end function
я={}
l.add("ElseOperation",я)
я.constructor=function(Ԁ,s)
N=self
N.classID="ElseOperation"
N.ast=Ԁ
N.body=null
N.isOperation=true
N.cpsWalker=s
return N
end function
ѐ={}
l.add("ForOperation",ѐ)
ѐ.constructor=function(Ԁ,s)
N=self
N.classID="ForOperation"
N.ast=Ԁ
N.variable=null
N.iterator=null
N.body=null
N.isOperation=true
N.cpsWalker=s
return N
end function
ѐ.run=function(ϫ)
N=self
ϯ=ϫ.fork("LOOP","TEMPORARY")
ӝ=N.variable.get(ϯ,N)
ё=N.iterator.get(ϯ)
ш={"isBreak":false,"isContinue":false}
ϯ.setMemory("loopContext",ш)
for М in ё
ш.isContinue=false
ϯ.set(ӝ.path,М)
N.body.run(ϯ)
if ш.isContinue then
continue
else if ш.isBreak then
break
end if
end for
end function
ђ={}
l.add("FunctionOperation",ђ)
ђ.Base=ђ
ђ.FunctionRegistry=ӟ
ђ.constructor=function(Ԁ,s)
N=self
N.id=md5(str(time))
N.classID="FunctionOperation"
N.ast=Ԁ
N.args=null
N.body=null
N.isOperation=true
N.context=null
N.isFunction=true
N.cpsWalker=s
N.FunctionRegistry.add(N)
return N
end function
ђ.getType=function()
return "function"
end function
ђ.fork=function(Ͼ)
N=self
і=(new N.Base).constructor(N.ast,N.cpsWalker)
і.args=N.args
і.body=N.body
і.context=Ͼ
return і
end function
ђ.createProxy=function()
N=self
return {"classID":"proxyFunction","id":N.id}
end function
ђ.get=function(ϫ)
return self
end function
ђ.toString=function()
return "Function"
end function
ђ.run=function(ϫ)
N=self
ϯ=ϫ.fork("FUNCTION","DEFAULT")
ї=ϫ.getMemory("args")
Ћ=N.args.get(ϯ)
ј={}
А=null
в={"value":А,"isReturn":false,"context":N.context}
ϯ.dbgr.debug({"type":"FunctionOperation","description":"prepare arguments","args":Ћ})
ϯ.setMemory("functionContext",в)
Э=0
љ=Ћ.len
while (Э<љ)
if ї.hasIndex(Э) then
ϯ.set(Ћ[Э],ї[Э])
end if
Э=(Э+1)
end while
ϯ.dbgr.debug({"type":"FunctionOperation","description":"execute body","opc":ϯ})
N.body.run(ϯ)
return в.value
end function
њ={}
l.add("IfStatementOperation",њ)
њ.constructor=function(Ԁ,s)
N=self
N.classID="IfStatementOperation"
N.ast=Ԁ
N.clauses=[]
N.isOperation=true
N.cpsWalker=s
return N
end function
њ.run=function(ϫ)
N=self
ћ=N.clauses
for ќ in ћ
ѝ=typeof(ќ)
if ((ѝ=="IfOperation") or (ѝ=="ElseIfOperation")) then
ў=ќ.condition.get(ϫ)
if ў then
ќ.body.run(ϫ)
return 
end if
else if (ѝ=="ElseOperation") then
ќ.body.run(ϫ)
return 
else
ϫ.dbgr.raise({"type":"IfStatementOperation","description":"Invalid operation in if statement","clause":ќ})
end if
end for
end function
џ={}
l.add("IfOperation",џ)
џ.constructor=function(Ԁ,s)
N=self
N.classID="IfOperation"
N.ast=Ԁ
N.condition=null
N.body=null
N.isOperation=true
N.cpsWalker=s
return N
end function
џ.run=function(ϫ)
N=self
ϫ.dbgr.raise(("Unexpected run call on "+typeof(N)))
end function
Ѡ={}
l.add("NewOperation",Ѡ)
Ѡ.dynResolve=Ф
Ѡ.ExpressionManager=d
Ѡ.OperationManager=l
Ѡ.constructor=function(Ԁ,s)
N=self
N.classID="NewOperation"
N.ast=Ԁ
N.arg=null
N.isOperation=true
N.cpsWalker=s
return N
end function
Ѡ.run=function(ϫ)
N=self
ϫ.dbgr.raise(("Unexpected run call on "+typeof(N)))
end function
Ѡ.get=function(ϫ)
N=self
Љ=N.arg
ϫ.dbgr.debug({"type":"NewOperation","description":"start","arg":@Љ})
if N.ExpressionManager.isInstanceOf(Љ) then
Љ=Љ.get(ϫ)
end if
ѡ=typeof(@Љ)
if ((((ѡ=="string") or (ѡ=="number")) or (ѡ=="boolean")) or (ѡ=="list")) then
ϫ.dbgr.raise({"type":"NewOperation","description":"Unexpected type for new operator","arg":Љ})
end if
Ѣ={}
ϫ.dbgr.debug({"type":"NewOperation","description":"start creation","arg":@Љ})
for Ќ in @Љ
if (typeof(Ќ.value)=="FunctionOperation") then
Ѣ[Ќ.key]=Ќ.value.fork(Ѣ)
else
Ѣ[Ќ.key]=Ќ.value
end if
end for
return (new Ѣ)
end function
ѣ={}
l.add("NotOperation",ѣ)
ѣ.dynResolve=Ф
ѣ.ExpressionManager=d
ѣ.OperationManager=l
ѣ.constructor=function(Ԁ,s)
N=self
N.classID="NotOperation"
N.ast=Ԁ
N.arg=null
N.isOperation=true
N.cpsWalker=s
return N
end function
ѣ.run=function(ϫ)
N=self
ϫ.dbgr.raise(("Unexpected run call on "+typeof(N)))
end function
ѣ.get=function(ϫ)
N=self
Љ=N.arg
if N.ExpressionManager.isInstanceOf(Љ) then
Љ=Љ.get(ϫ)
end if
return not Љ
end function
Ѥ={}
l.add("ReferenceOperation",Ѥ)
Ѥ.dynResolve=Ф
Ѥ.ExpressionManager=d
Ѥ.OperationManager=l
Ѥ.constructor=function(Ԁ,s)
N=self
N.classID="ReferenceOperation"
N.ast=Ԁ
N.arg=null
N.isOperation=true
N.cpsWalker=s
return N
end function
Ѥ.run=function(ϫ)
N=self
Љ=@N.arg
ѥ=null
if N.ExpressionManager.isInstanceOf(@Љ) then
ѥ=Љ.get(ϫ)
else
ϫ.dbgr.raise(["Unexpected reference",N.arg].join(" "))
return null
end if
return @ѥ
end function
Ѥ.get=function(ϫ)
N=self
Љ=@N.arg
if (N.ExpressionManager.isInstanceOf(@Љ) or N.OperationManager.isInstanceOf(@Љ)) then
Љ=Љ.get(ϫ,N)
else
ϫ.dbgr.raise(["Unexpected reference",N.arg].join(" "))
return null
end if
if (typeof(@Љ)!="pathResult") then
ϫ.dbgr.raise(["Unexpected reference result",@Љ].join(" "))
return @Љ
end if
ϫ.dbgr.debug({"type":"ReferenceOperation","description":"handle","arg":@Љ})
Ϸ=Љ.handle
ϸ=typeof(@Ϸ)
ϫ.dbgr.debug({"type":"ReferenceOperation","description":"handle type after resolve","handleType":ϸ})
if (ϸ!="null") then
if (((ϸ!="string") and (ϸ!="number")) and (ϸ!="boolean")) then
ѥ=N.dynResolve.get(@Ϸ,Љ.path)
ϫ.dbgr.debug({"type":"ReferenceOperation","description":"returns resolved value of handle","resolvedValue":@ѥ})
if (typeof(@ѥ)=="FunctionOperation") then
return ѥ.createProxy
else if (N.ExpressionManager.isInstanceOf(@ѥ) or N.OperationManager.isInstanceOf(@ѥ)) then
return ѥ.get(ϫ)
end if
return @ѥ
end if
ϫ.dbgr.raise({"type":"ReferenceOperation","description":"Unexpected handle in reference statement","handle":Ϸ})
return Ϸ
end if
ѥ=ϫ.get(Љ.path)
ϯ.dbgr.debug({"type":"ReferenceOperation","description":"get with opc","value":@ѥ,"opc":ϫ})
if (typeof(@ѥ)=="FunctionOperation") then
return ѥ.createProxy
else if (N.ExpressionManager.isInstanceOf(@ѥ) or N.OperationManager.isInstanceOf(@ѥ)) then
return ѥ.get(ϫ)
end if
return @ѥ
end function
Ѧ={}
l.add("ReturnOperation",Ѧ)
Ѧ.ExpressionManager=d
Ѧ.OperationManager=l
Ѧ.constructor=function(Ԁ,s)
N=self
N.classID="ReturnOperation"
N.ast=Ԁ
N.arg=null
N.isOperation=true
N.cpsWalker=s
return N
end function
Ѧ.run=function(ϫ)
N=self
в=ϫ.getMemory("functionContext")
Љ=N.arg
if N.ExpressionManager.isInstanceOf(Љ) then
Љ=N.arg.get(ϫ)
else if N.OperationManager.isInstanceOf(Љ) then
Љ=N.arg.get(ϫ)
end if
в.value=Љ
в.isReturn=true
end function
ѧ={}
l.add("TopOperation",ѧ)
ѧ.constructor=function()
N=self
N.classID="TopOperation"
N.body=null
N.isOperation=true
return N
end function
ѧ.run=function(ϫ,Ѩ)
N=self
if not Ѩ then
ϯ=ϫ.fork("GLOBAL","DEFAULT")
ϯ.extend({"globals":ϯ.createProxy})
end if
N.body.run(ϯ)
return ϯ
end function
Ѫ={}
d.add("ImportCodeExpression",Ѫ)
Ѫ.CodeParser=Ц
Ѫ.TopOperation=ѧ
Ѫ.constructor=function(Ԁ,s)
N=self
t=function(u)
N=self
ѫ=u.filepath.value
Ѭ=get_shell.host_computer.File(ѫ)
if not Ѭ then
N.cpsWalker.exception((("File "+ѫ)+" cannot be found."))
return null
else if not Ѭ.has_permission("r") then
N.cpsWalker.exception((("Has no permission to read "+ѫ)+"."))
return null
else if Ѭ.is_binary then
N.cpsWalker.exception((("File "+ѫ)+" is a binary."))
return null
else if Ѭ.is_folder then
N.cpsWalker.exception((("File "+ѫ)+" is a folder."))
return null
end if
ѳ=(new N.CodeParser).constructor(Ѭ.get_content)
ѵ=ѳ.parseChunk
if ѳ.hasError then
N.cpsWalker.exception(ѳ.getErrors.join(char(10)))
return null
end if
ѷ=(new N.TopOperation).constructor
ѷ.body=N.cpsWalker.visit(ѵ)
return ѷ
end function
_={"cpsWalker":s,"build":@t,"CodeParser":N.CodeParser,"TopOperation":N.TopOperation}
N.classID="ImportCodeExpression"
N.body=null
N.isExpression=true
N.ast=Ԁ
N.cpsWalker=s
N.expr=_.build(Ԁ)
return N
end function
Ѫ.get=function(ϫ,Ϭ)
N=self
if (N.expr==null) then
ϫ.dbgr.raise((("Import "+N.ast.filepath.value)+" is not available."))
return null
end if
return N.expr.run(ϫ,true)
end function
Ѹ={}
l.add("WhileOperation",Ѹ)
Ѹ.ExpressionManager=d
Ѹ.OperationManager=l
Ѹ.constructor=function(Ԁ,s)
N=self
N.classID="WhileOperation"
N.ast=Ԁ
N.condition=null
N.body=null
N.isOperation=true
N.cpsWalker=s
return N
end function
Ѹ.run=function(ϫ)
N=self
ϯ=ϫ.fork("LOOP","TEMPORARY")
ш={"isBreak":false,"isContinue":false}
э={"instance":N,"opc":ϯ}
э.is=function()
N=self.instance
if N.ExpressionManager.isInstanceOf(N.condition) then
return N.condition.get(self.opc)
end if
return N.condition
end function
ϯ.setMemory("loopContext",ш)
while э.is
ш.isContinue=false
N.body.run(ϯ)
if ш.isContinue then
continue
else if ш.isBreak then
break
end if
end while
end function
ѹ={}
ѹ.AssignmentStatement=function(s,Ќ)
q=s.ExpressionManager.get("AssignExpression")
return (new q).constructor(Ќ,s)
end function
ѹ.MemberExpression=function(s,Ќ)
Щ=s.ExpressionManager.get("PathExpression")
return (new Щ).constructor(Ќ,s)
end function
ѹ.FunctionDeclaration=function(s,Ќ)
ђ=s.OperationManager.get("FunctionOperation")
й=s.OperationManager.get("ArgumentOperation")
п=s.OperationManager.get("BodyOperation")
n=(new ђ).constructor(Ќ,s)
Ћ=(new й).constructor(Ќ.parameters,s)
ю=(new п).constructor(Ќ.body,s)
for Ѿ in Ќ.parameters
ϵ=s.visit(Ѿ.path)
о=s.visit(Ѿ.defaultValue)
Ћ.stack.push({"classID":"arg","path":ϵ,"defaultValue":о})
end for
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.args=Ћ
n.body=ю
return n
end function
ѹ.MapConstructorExpression=function(s,Ќ)
Ч=s.ExpressionManager.get("MapExpression")
return (new Ч).constructor(Ќ,s)
end function
ѹ.Identifier=function(s,Ќ)
Щ=s.ExpressionManager.get("PathExpression")
return (new Щ).constructor(Ќ,s)
end function
ѹ.ReturnStatement=function(s,Ќ)
Ѧ=s.OperationManager.get("ReturnOperation")
n=(new Ѧ).constructor(Ќ,s)
n.arg=s.visit(Ќ.arguments.pull)
return n
end function
ѹ.NumericLiteral=function(s,Ќ)
return Ќ.value
end function
ѹ.WhileStatement=function(s,Ќ)
Ѹ=s.OperationManager.get("WhileOperation")
п=s.OperationManager.get("BodyOperation")
n=(new Ѹ).constructor(Ќ,s)
ю=(new п).constructor(Ќ.body,s)
n.condition=s.visit(Ќ.condition)
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.body=ю
return n
end function
ѹ.StringLiteral=function(s,Ќ)
return Ќ.value
end function
ѹ.IndexExpression=function(s,Ќ)
Щ=s.ExpressionManager.get("PathExpression")
return (new Щ).constructor(Ќ,s)
end function
ѹ.IfShortcutStatement=function(s,Ќ)
њ=s.OperationManager.get("IfStatementOperation")
n=(new њ).constructor(Ќ,s)
for ҈ in Ќ.clauses
n.clauses.push(s.visit(҈))
end for
return n
end function
ѹ.IfShortcutClause=function(s,Ќ)
џ=s.OperationManager.get("IfOperation")
п=s.OperationManager.get("BodyOperation")
n=(new џ).constructor(Ќ,s)
ю=(new п).constructor(Ќ.statement,s)
n.condition=s.visit(Ќ.condition)
ю.stack.push(s.visit(Ќ.statement))
n.body=ю
return n
end function
ѹ.ElseifShortcutClause=function(s,Ќ)
ь=s.OperationManager.get("ElseIfOperation")
п=s.OperationManager.get("BodyOperation")
n=(new ь).constructor(Ќ,s)
ю=(new п).constructor(Ќ.statement,s)
n.condition=s.visit(Ќ.condition)
ю.stack.push(s.visit(Ќ.statement))
n.body=ю
return n
end function
ѹ.ElseShortcutClause=function(s,Ќ)
я=s.OperationManager.get("ElseOperation")
п=s.OperationManager.get("BodyOperation")
n=(new я).constructor(Ќ,s)
ю=(new п).constructor(Ќ.statement,s)
ю.stack.push(s.visit(Ќ.statement))
n.body=ю
return n
end function
ѹ.NilLiteral=function(s,Ќ)
return null
end function
ѹ.ForGenericStatement=function(s,Ќ)
ѐ=s.OperationManager.get("ForOperation")
п=s.OperationManager.get("BodyOperation")
n=(new ѐ).constructor(Ќ,s)
ю=(new п).constructor(Ќ.body,s)
n.variable=s.visit(Ќ.variable)
n.iterator=s.visit(Ќ.iterator)
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.body=ю
return n
end function
ѹ.IfStatement=function(s,Ќ)
њ=s.OperationManager.get("IfStatementOperation")
n=(new њ).constructor(Ќ,s)
for ҈ in Ќ.clauses
n.clauses.push(s.visit(҈))
end for
return n
end function
ѹ.IfClause=function(s,Ќ)
џ=s.OperationManager.get("IfOperation")
п=s.OperationManager.get("BodyOperation")
n=(new џ).constructor(Ќ,s)
ю=(new п).constructor(Ќ.body,s)
n.condition=s.visit(Ќ.condition)
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.body=ю
return n
end function
ѹ.ElseifClause=function(s,Ќ)
ь=s.OperationManager.get("ElseIfOperation")
п=s.OperationManager.get("BodyOperation")
n=(new ь).constructor(Ќ,s)
ю=(new п).constructor(Ќ.body,s)
n.condition=s.visit(Ќ.condition)
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.body=ю
return n
end function
ѹ.ElseClause=function(s,Ќ)
я=s.OperationManager.get("ElseOperation")
п=s.OperationManager.get("BodyOperation")
n=(new я).constructor(Ќ,s)
ю=(new п).constructor(Ќ.body,s)
for ѿ in Ќ.body
ю.stack.push(s.visit(ѿ))
end for
n.body=ю
return n
end function
ѹ.NegationExpression=function(s,Ќ)
ѣ=s.OperationManager.get("NotOperation")
n=(new ѣ).constructor(Ќ,s)
n.arg=s.visit(Ќ.argument)
return n
end function
ѹ.ContinueStatement=function(s,Ќ)
щ=s.OperationManager.get("ContinueOperation")
return (new щ).constructor(Ќ,s)
end function
ѹ.BreakStatement=function(s,Ќ)
ч=s.OperationManager.get("BreakOperation")
return (new ч).constructor(Ќ,s)
end function
ѹ.CallExpression=function(s,Ќ)
Њ=s.ExpressionManager.get("CallExpression")
return (new Њ).constructor(Ќ,s)
end function
ѹ.CallStatement=function(s,Ќ)
Њ=s.ExpressionManager.get("CallExpression")
return (new Њ).constructor(Ќ,s)
end function
ѹ.ImportCodeExpression=function(s,Ќ)
Ѫ=s.ExpressionManager.get("ImportCodeExpression")
return (new Ѫ).constructor(Ќ,s)
end function
ѹ.FeatureDebuggerExpression=function(s,Ќ)
ъ=s.OperationManager.get("DebuggerOperation")
return (new ъ).constructor(Ќ,s)
end function
ѹ.ListConstructorExpression=function(s,Ќ)
К=s.ExpressionManager.get("ListExpression")
return (new К).constructor(Ќ,s)
end function
ѹ.BooleanLiteral=function(s,Ќ)
return Ќ.value
end function
ѹ.EmptyExpression=function(s,Ќ)
return 
end function
ѹ.BinaryExpression=function(s,Ќ)
Т=s.ExpressionManager.get("LogicalAndBinaryExpression")
return (new Т).constructor(Ќ,s)
end function
ѹ.BinaryNegatedExpression=function(s,Ќ)
Ђ=s.ExpressionManager.get("BinaryNegatedExpression")
return (new Ђ).constructor(Ќ,s)
end function
ѹ.LogicalExpression=function(s,Ќ)
Т=s.ExpressionManager.get("LogicalAndBinaryExpression")
return (new Т).constructor(Ќ,s)
end function
ѹ.UnaryExpression=function(s,Ќ)
n=null
Ѥ=s.OperationManager.get("ReferenceOperation")
Ѡ=s.OperationManager.get("NewOperation")
if ("@"==Ќ.operator) then
n=(new Ѥ).constructor(Ќ,s)
else if ("new"==Ќ.operator) then
n=(new Ѡ).constructor(Ќ,s)
end if
n.arg=s.visit(Ќ.argument)
return n
end function
ѹ.Chunk=function(s,Ќ)
п=s.OperationManager.get("BodyOperation")
n=(new п).constructor(Ќ,s)
for ѿ in Ќ.body
n.stack.push(s.visit(ѿ))
end for
return n
end function
Ҡ={}
Ҡ.defaultMapper=ѹ
Ҡ.OperationManager=l
Ҡ.ExpressionManager=d
Ҡ.constructor=function()
N=self
N.mapper=N.defaultMapper
N.status={"errors":[]}
return N
end function
Ҡ.visit=function(Ҥ)
N=self
if (Ҥ==null) then
return 
end if
if (Ҥ.type==null) then
N.exception("Unexpected as type")
return 
end if
if not N.mapper.hasIndex(Ҥ.type) then
N.exception(("Type does not exist "+Ҥ.type))
return 
end if
Ҧ=@N.mapper[Ҥ.type]
А=Ҧ(N,Ҥ)
return А
end function
Ҡ.exception=function(ҧ)
N=self
Ҩ=("[CPSEvaluatorWalker] Error: "+ҧ)
debug(Ҩ)
N.status.errors.push(Ҩ)
return null
end function
Ҡ.hasError=function()
return (self.status.errors.len>0)
end function
Ҡ.getErrors=function()
return self.status.errors
end function
Ҫ={}
Ҫ.TopOperation=ѧ
Ҫ.CPSEvaluatorWalker=Ҡ
Ҫ.constructor=function(ѵ)
N=self
N.chunk=ѵ
N.status={"errors":[]}
return N
end function
Ҫ.hasError=function()
return (self.status.errors.len>0)
end function
Ҫ.getErrors=function()
return self.status.errors
end function
Ҫ.digest=function()
N=self
s=(new N.CPSEvaluatorWalker).constructor
ҫ=s.visit(N.chunk)
if s.hasError then
N.status.errors=(N.status.errors+s.getErrors)
return null
end if
ѷ=(new N.TopOperation).constructor
ѷ.body=ҫ
return ѷ
end function
Ҭ={}
Ҭ.dynResolve=Ф
Ҭ.ScopeRegistry=p
Ҭ.constructor=function(Ͼ)
N=self
N.id=md5(str(time))
N.classID="scope"
N.isScope=true
N.context=Ͼ
N.refs={}
N.ScopeRegistry.add(N)
return N
end function
Ҭ.valueOf=function()
return self.refs
end function
Ҭ.createProxy=function()
N=self
return {"classID":"proxyScope","id":N.id}
end function
Ҭ.extend=function(Ш)
N=self
if (Ш==null) then
Ш={}
end if
for з in Ш
N.refs[з.key]=@з.value
end for
return N
end function
Ҭ.set=function(ϵ,М)
N=self
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
ү=([]+ϵ)
X=N.refs
Ұ=ү.pop
П=ү.pull
И=X
if (П!=null) then
if (typeof(N.dynResolve.get(@И,П))!="null") then
И=@И[П]
д=typeof(@И)
if ((д=="list") or (д=="map")) then
return N.dynResolve.set(@И,(ү+[Ұ]),@М)
else if (д=="scope") then
return И.set((ү+[Ұ]),@М)
end if
else if (N.dynResolve.get(N,"context.previous") and not N.dynResolve.get(N,"context.previous.isProteced")) then
return N.context.previous.set(ϵ,@М)
else if (ү.len>0) then
exit(("Cannot set path "+ϵ.join(".")))
end if
end if
д=typeof(@И)
if (((((@И!=null) and (д!="boolean")) and (д!="string")) and (д!="number")) and (д!="null")) then
И[Ұ]=@М
else
exit(("Cannot set path "+ϵ.join(".")))
end if
end function
Ҭ.get=function(ϵ)
N=self
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
ү=([]+ϵ)
X=N.refs
П=ү.pull
И=X
if (П!=null) then
if (typeof(N.dynResolve.get(@И,П))!="null") then
И=@И[П]
д=typeof(@И)
if (ү.len>0) then
if (д=="scope") then
return И.get(ү)
else if ((д!="number") or (д!="boolean")) then
return N.dynResolve.get(@И,ү)
end if
end if
else if (N.context.previous!=null) then
return N.context.previous.get(ϵ)
else
И=null
end if
end if
return @И
end function
Ҭ.getCallable=function(ϵ)
N=self
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
ү=([]+ϵ)
X=N.refs
П=ү.pull
И=X
Ͼ=null
if (П!=null) then
if (typeof(N.dynResolve.get(@И,П))!="null") then
Ͼ=@И
И=@И[П]
д=typeof(@И)
if (д=="scope") then
return И.getCallable(ү)
else if ((д!="number") or (д!="boolean")) then
return N.dynResolve.getCallable(@И,ү)
end if
else if N.dynResolve.get(N,"context.previous") then
return N.context.previous.getCallable(ϵ)
else
И=null
end if
end if
return {"origin":@И,"context":Ͼ}
end function
ҳ={}
ҳ.TYPE={"API":"API","GLOBAL":"GLOBAL","FUNCTION":"FUNCTION","LOOP":"LOOP","MAP":"MAP","CALL":"CALL"}
ҳ.STATE={"TEMPORARY":"TEMPORARY","DEFAULT":"DEFAULT"}
ҳ.Base=ҳ
ҳ.Scope=Ҭ
ҳ.constructor=function(Ҷ,ҷ=false)
N=self
N.classID="operationContext"
N.previous=null
N.type=N.TYPE.API
N.state=N.STATE.DEFAULT
N.scope=(new N.Scope).constructor(N)
N.isProteced=ҷ
N.dbgr=Ҷ
N.memory={}
return N
end function
ҳ.valueOf=function()
return self.scope.valueOf
end function
ҳ.createProxy=function()
return self.scope.createProxy
end function
ҳ.extend=function(Ш)
N=self
if (N.state==N.STATE.TEMPORARY) then
N.previous.extend(Ш)
else
N.scope.extend(Ш)
end if
return N
end function
ҳ.set=function(ϵ,М)
N=self
if (N.state==N.STATE.TEMPORARY) then
N.previous.set(ϵ,М)
else
N.scope.set(ϵ,М)
end if
return N
end function
ҳ.get=function(ϵ)
N=self
if (N.state==N.STATE.TEMPORARY) then
return N.previous.get(ϵ)
end if
return N.scope.get(ϵ)
end function
ҳ.setMemory=function(f,М)
N=self
N.memory[f]=М
return N
end function
ҳ.getMemory=function(f)
N=self
if N.memory.hasIndex(f) then
return N.memory[f]
end if
return null
end function
ҳ.getCallable=function(ϵ)
N=self
if (N.state==N.STATE.TEMPORARY) then
return N.previous.getCallable(ϵ)
end if
return N.scope.getCallable(ϵ)
end function
ҳ.fork=function(w,ҹ)
N=self
ϯ=(new N.Base).constructor(N.dbgr)
ϯ.previous=N
ϯ.type=w
ϯ.state=ҹ
if ((N.type==N.TYPE.FUNCTION) or (N.type==N.TYPE.GLOBAL)) then
ϯ.extend({"locals":ϯ.createProxy})
end if
if (w!=N.TYPE.FUNCTION) then
if (w!=N.TYPE.LOOP) then
ϯ.setMemory("loopContext",N.getMemory("loopContext"))
end if
ϯ.setMemory("functionContext",N.getMemory("functionContext"))
end if
return ϯ
end function
Ӏ={}
Ӏ.CodeParser=Ц
Ӏ.CPSEvaluatorWalker=Ҡ
Ӏ.TopOperation=ѧ
Ӏ.Base=Ӏ
Ӏ.constructor=function(ϲ,debug)
N=self
N.customRaise=ϲ
N.customDebug=debug
N.breakpoint=false
N.maxLevel=4
return N
end function
Ӏ.raise=function(Ӆ)
N=self
if (@N.customRaise!=null) then
N.customRaise(Ӆ)
return null
end if
print("[ERROR]:")
N.inspect(Ӆ)
return null
end function
Ӏ.debug=function(Ӆ)
N=self
if (@N.customDebug!=null) then
N.customDebug(Ӆ)
return null
end if
if debug("[DEBUG]") then
N.inspect(Ӆ)
end if
return null
end function
Ӏ.setBreakPoint=function(Ӈ)
N=self
N.breakpoint=Ӈ
return N
end function
Ӏ.getBreakPoint=function()
N=self
return N.breakpoint
end function
Ӏ.inspectIterator=function(f,М,Ӊ)
N=self
и=typeof(@М)
ӊ=(Ӊ+1)
Ӌ=(char(9)*(Ӊ+1))
if (Ӊ==N.maxLevel) then
print((Ӌ+"[REDACTED]"))
return null
end if
if ((((и=="string") or (и=="boolean")) or (и=="number")) or (и=="function")) then
print(((((((Ӌ+"[")+и)+"] <b>")+f)+"</b>: ")+@М))
else if (и=="null") then
print((((((Ӌ+"[")+и)+"] <b>")+f)+"</b>: null"))
else if (и=="list") then
print((((((Ӌ+"[")+и)+"] <b>")+f)+"</b>:"))
Э=0
for Ќ in М
N.inspectIterator(Э,@Ќ,ӊ)
Э=(Э+1)
end for
else if (и=="map") then
print((((((Ӌ+"[")+и)+"] <b>")+f)+"</b>:"))
for Ќ in М
N.inspectIterator(Ќ.key,@Ќ.value,ӊ)
end for
else
print(((((((Ӌ+"[")+и)+"] <b>")+f)+"</b>: ")+@М))
end if
return null
end function
Ӏ.inspect=function(j)
N=self
Э=0
for Ќ in j
N.inspectIterator(Ќ.key,@Ќ.value,0)
Э=(Э+1)
end for
if (Э==0) then
print("{}")
end if
return null
end function
Ӏ.inspectOperationContext=function(ϫ)
N=self
Ӎ=ϫ
while Ӎ
print((("<b>"+Ӎ.type)+"</b>:"))
N.inspect(Ӎ.scope.refs)
Ӎ=Ӎ.previous
end while
return null
end function
Ӏ.showInteractOptions=function()
print(((("<b>Interactive dbgr mode</b>"+char(10))+char(10))+"<b>Actions</b>:"))
print((char(9)+"<b>:q</b> exit"))
print((char(9)+"<b>:i</b> show context info"))
print((char(9)+"<b>:n</b> next line"))
return null
end function
Ӏ.interact=function(ϫ,Ѐ)
N=self
Ӎ=ϫ
while N.breakpoint
N.showInteractOptions
ӏ=user_input((("[Line: "+Ѐ)+"]: "))
ӏ=ӏ.trim
if (ӏ==":n") then
return null
else if (ӏ==":q") then
N.setBreakPoint(false)
else if (ӏ==":i") then
N.inspectOperationContext(ϫ)
else
ѳ=(new N.CodeParser).constructor(ӏ)
ѵ=ѳ.parseChunk
if ѳ.hasError then
print(ѳ.getErrors.join(char(10)))
else
s=(new N.CPSEvaluatorWalker).constructor
ѷ=(new N.TopOperation).constructor
ϯ=ϫ.fork("CALL","TEMPORARY")
ϯ.dbgr=(new N.Base).constructor
ѷ.body=s.visit(ѵ)
ѷ.run(ϯ,true)
end if
end if
end while
end function
J={}
J.CodeParser=Ц
J.CPSEvaluator=Ҫ
J.OperationContext=ҳ
J.Debugger=Ӏ
J.constructor=function(M,O,params,ϲ,debug)
N=self
N.code=M
N.api=O
N.params=params
N.dbgr=(new N.Debugger).constructor(@ϲ,@debug)
N.status={"errors":[]}
return N
end function
J.hasError=function()
return (self.status.errors.len>0)
end function
J.getErrors=function()
return self.status.errors
end function
J.digest=function()
N=self
ѳ=(new N.CodeParser).constructor(N.code)
ѵ=ѳ.parseChunk
if ѳ.hasError then
N.status.errors=(N.status.errors+ѳ.getErrors)
return null
end if
ӑ=(new N.CPSEvaluator).constructor(ѵ)
Ӓ=ӑ.digest
if ӑ.hasError then
N.status.errors=(N.status.errors+ӑ.getErrors)
return null
end if
ӓ=(new N.OperationContext).constructor(N.dbgr,true)
N.api.typeof=function(Є)
Ӕ=typeof(@Є)
if ((Ӕ=="FunctionOperation") or (Ӕ=="proxyFunction")) then
return "function"
end if
return Ӕ
end function
N.api.params=N.params
ӓ.extend(N.api)
return Ӓ.run(ӓ)
end function
return J
end function
injector.def("interpreter",["dynResolve","parser","dynApply"],@Z)
ӕ=function()
Ә={}
Ӗ={}
Ӗ[0]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref)
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec
end function
Ӗ[1]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0])
end function
Ӗ[2]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1])
end function
Ӗ[3]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2])
end function
Ӗ[4]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3])
end function
Ӗ[5]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4])
end function
Ӗ[6]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5])
end function
Ӗ[7]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6])
end function
Ӗ[8]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7])
end function
Ӗ[9]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7],@ӗ.args[8])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7],@ӗ.args[8])
end function
Ӗ[10]=function(ӗ)
if (typeof(ӗ.ctx)=="dynProxy") then
Ҧ=@ӗ.fn
return Ҧ(ӗ.ctx.__ref,@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7],@ӗ.args[8],@ӗ.args[9])
end if
ӗ.ctx.__dynApplyExec=@ӗ.fn
return ӗ.ctx.__dynApplyExec(@ӗ.args[0],@ӗ.args[1],@ӗ.args[2],@ӗ.args[3],@ӗ.args[4],@ӗ.args[5],@ӗ.args[6],@ӗ.args[7],@ӗ.args[8],@ӗ.args[9])
end function
Ә.METHODS=Ӗ
Ә.apply=function(Ҧ,Ћ,Ͼ)
N=self
if (Ћ==null) then
Ћ=[]
end if
if (Ͼ==null) then
Ͼ=globals
end if
Ӝ=Ћ.len
if N.METHODS.hasIndex(Ӝ) then
Ӟ=@N.METHODS[Ӝ]
return Ӟ({"classID":"apply","ctx":Ͼ,"fn":@Ҧ,"args":Ћ})
end if
exit("Error: dynApply only supports 10 arguments")
end function
return Ә
end function
injector.def("dynApply",@ӕ)
Ӡ=function()
Ф={}
Ф.nativeHasIndex=@{}["hasIndex"]
Ф.MODES={"STRICT":0,"WARN":1,"IGNORE":2}
Ф.mode=Ф.MODES.IGNORE
Ф.getMapIsa=function(Є)
Ϸ={}
Ӧ={}
Ӧ.__ref=Є
Ӧ.classID="dynProxy"
Ӧ.hasIndex=@Ϸ["hasIndex"]
Ӧ.indexOf=@Ϸ["indexOf"]
Ӧ.push=@Ϸ["push"]
Ӧ.remove=@Ϸ["remove"]
Ӧ.indexes=@Ϸ["indexes"]
Ӧ.len=@Ϸ["len"]
Ӧ.pop=@Ϸ["pop"]
Ӧ.shuffle=@Ϸ["shuffle"]
Ӧ.sum=@Ϸ["sum"]
Ӧ.values=@Ϸ["values"]
return Ӧ
end function
Ф.getListIsa=function(Є)
Ϸ=[]
Ӧ={}
Ӧ.__ref=Є
Ӧ.classID="dynProxy"
Ӧ.hasIndex=@Ϸ["hasIndex"]
Ӧ.indexOf=@Ϸ["indexOf"]
Ӧ.remove=@Ϸ["remove"]
Ӧ.join=@Ϸ["join"]
Ӧ.push=@Ϸ["push"]
Ӧ.pop=@Ϸ["pop"]
Ӧ.pull=@Ϸ["pull"]
Ӧ.shuffle=@Ϸ["shuffle"]
Ӧ.reverse=@Ϸ["reverse"]
Ӧ.sort=@Ϸ["sort"]
Ӧ.indexes=@Ϸ["indexes"]
Ӧ.len=@Ϸ["len"]
Ӧ.sum=@Ϸ["sum"]
Ӧ.values=@Ϸ["values"]
return Ӧ
end function
Ф.getStringIsa=function(Є)
Ϸ=""
Ӧ={}
Ӧ.__ref=Є
Ӧ.classID="dynProxy"
Ӧ.remove=@Ϸ["remove"]
Ӧ.hasIndex=@Ϸ["hasIndex"]
Ӧ.indexOf=@Ϸ["indexOf"]
Ӧ.lastIndexOf=@Ϸ["lastIndexOf"]
Ӧ.split=@Ϸ["split"]
Ӧ.replace=@Ϸ["replace"]
Ӧ.trim=@Ϸ["trim"]
Ӧ.indexes=@Ϸ["indexes"]
Ӧ.code=@Ϸ["code"]
Ӧ.len=@Ϸ["len"]
Ӧ.lower=@Ϸ["lower"]
Ӧ.upper=@Ϸ["upper"]
Ӧ.val=@Ϸ["val"]
Ӧ.values=@Ϸ["values"]
Ӧ.to_int=@Ϸ["to_int"]
return Ӧ
end function
Ф.API_KEYS=["aptclientLib","computer","cryptoLib","file","libMail","MetaxploitLib","MetaLib","MetaMail","NetSession","port","router","shell","ftpshell"]
Ф.getApiIsa=function(Є)
Ϸ=""
Ӧ={}
Ӧ.__ref=Є
Ӧ.classID="dynProxy"
for Ќ in Є.__isa
Ӧ[Ќ.key]=@Ќ.value
end for
return Ӧ
end function
Ф.detach=function(Є)
N=self
hasIndex=@N.hasIndex
if N.usesNativeIsa(@Є) then
w=typeof(Є)
if (w=="map") then
return N.getMapIsa(Є)
else if (w=="list") then
return N.getListIsa(Є)
else if (w=="string") then
return N.getStringIsa(Є)
else if (N.API_KEYS.indexOf(w)!=null) then
return N.getApiIsa(Є)
end if
end if
return @Є
end function
Ф.usesNativeIsa=function(Є)
N=self
w=typeof(@Є)
return ((((w=="map") or (w=="list")) or (w=="string")) or (N.API_KEYS.indexOf(w)!=null))
end function
Ф.get=function(Є,ϵ,о)
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
N=self
И=@Є
hasIndex=@N.nativeHasIndex
ӻ=([]+ϵ)
while (@Є!=null)
if (ӻ.len==0) then break
Ӽ=typeof(@Є)
ӽ=ӻ.pull
if (((Ӽ=="list") or (Ӽ=="string")) and (typeof(ӽ)=="string")) then
ӽ=ӽ.to_int
if (typeof(ӽ)=="string") then
Є=N.detach(Є)
end if
end if
if hasIndex(@Є,ӽ) then
Є=@Є[ӽ]
else if (((typeof(@Є)!="string") and hasIndex(@Є,"__isa")) and hasIndex(Є.__isa,ӽ)) then
Є=@Є.__isa[ӽ]
else if N.usesNativeIsa(@Є) then
Ӿ=N.detach(Є)
if Ӿ.hasIndex(ӽ) then
Є=@Є[ӽ]
else
Є=null
end if
else
Є=null
end if
end while
if (typeof(@Є)=="null") then
if (typeof(@о)=="null") then
N.raise(((("[WARNING] Cannot get value "+ϵ.join(" "))+" from ")+@И))
end if
return @о
end if
return @Є
end function
Ф.set=function(Є,ϵ,ӿ)
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
N=self
И=@Є
hasIndex=@N.hasIndex
ӻ=([]+ϵ)
Ұ=ӻ.pop
if (Ұ==null) then
return false
end if
Є=N.get(Є,ӻ)
Ӽ=typeof(@Є)
if (((((typeof(Є)=="null") or (Ӽ=="string")) or (Ӽ=="boolean")) or (Ӽ=="number")) or (Ӽ=="function")) then
N.raise(((("[WARNING] Cannot set value "+ϵ.join(" "))+" on ")+@И))
return false
end if
Є[Ұ]=@ӿ
return true
end function
Ф.getCallable=function(Є,ϵ)
if (typeof(ϵ)=="string") then
ϵ=ϵ.split(".")
end if
N=self
И=@Є
Ͼ=null
hasIndex=@N.hasIndex
ӻ=([]+ϵ)
while (@Є!=null)
if (ӻ.len==0) then break
Ӽ=typeof(@Є)
ӽ=ӻ.pull
if (((Ӽ=="list") or (Ӽ=="string")) and (typeof(ӽ)=="string")) then
ӽ=ӽ.to_int
if (typeof(ӽ)=="string") then
Ͼ=Є
Є=N.detach(Є)
Ӽ=typeof(@Є)
end if
end if
if (N.API_KEYS.indexOf(Ӽ)!=null) then
Ͼ=N.detach(Є)
Є=@Є[ӽ]
else if hasIndex(@Є,ӽ) then
Ͼ=@Є
Є=@Є[ӽ]
else if (((Ӽ!="string") and hasIndex(@Є,"__isa")) and hasIndex(Є.__isa,ӽ)) then
Ͼ=@Є
Є=@Є.__isa[ӽ]
else if N.usesNativeIsa(@Є) then
Ͼ=Є
Ӿ=N.detach(Є)
if Ӿ.hasIndex(ӽ) then
Є=@Є[ӽ]
else
Є=null
end if
else
Є=null
end if
end while
if (typeof(@Є)=="null") then
N.raise(((("[WARNING] Cannot get callable value "+ϵ.join(" "))+" from ")+@И))
end if
return {"origin":@Є,"context":Ͼ}
end function
Ф.raise=function(ԁ)
N=self
if (N.mode==N.MODES.WARN) then
print(ԁ)
else if (N.mode==N.MODES.STRICT) then
exit(ԁ)
end if
end function
return Ф
end function
injector.def("dynResolve",@Ӡ)
H=function(I)
J=I[0]
K={}
K.Interpreter=J
K.execute=function(M,params)
N=self
O={}
O.print=function(str)
print(str)
return null
end function
O.wait=@wait
O.time=@time
O.typeof=@typeof
O.md5=@md5
O.get_router=@get_router
O.get_shell=@get_shell
O.nslookup=@nslookup
O.whois=@whois
O.is_valid_ip=@is_valid_ip
O.is_lan_ip=@is_lan_ip
O.command_info=@command_info
O.current_date=@current_date
O.current_path=@current_path
O.parent_path=@parent_path
O.home_dir=@home_dir
O.program_path=@program_path
O.active_user=@active_user
O.user_mail_address=@user_mail_address
O.user_bank_number=@user_bank_number
O.format_columns=@format_columns
O.user_input=@user_input
O.include_lib=@include_lib
O.bitwise=@bitwise
O.clear_screen=@clear_screen
O.slice=@slice
O.str=@str
O.hash=@hash
O.abs=@abs
O.acos=@acos
O.asin=@asin
O.atan=@atan
O.tan=@tan
O.cos=@cos
O.sin=@sin
O.char=@char
O.floor=@floor
O.range=@range
O.round=@round
O.rnd=@rnd
O.sign=@sign
O.sqrt=@sqrt
O.str=@str
O.ceil=@ceil
O.pi=@pi
O.include_lib=@include_lib
P=time
print((("Executing "+char(10))+M))
Q=(new N.Interpreter).constructor(M,O,params)
R=Q.digest
if Q.hasError then
print(Q.getErrors.join(char(10)))
end if
print(("Executed in "+(time-P)))
print("Global Context: ")
print(R.scope.refs)
end function
return K
end function
injector.def("teditInterpreter",["interpreter"],@H)